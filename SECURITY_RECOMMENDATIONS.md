# Рекомендации по улучшению безопасности Maksum (VK SOSA)

Документ описывает меры по защите соцсети: перехват трафика, ключи, приватность пользователей, защита от атак и лучшие практики.

---

## 1. Защита трафика (перехват, MITM)

### 1.1 HTTPS везде

- **Сайт и API должны работать только по HTTPS** в продакшене. Иначе логины, токены и личные данные передаются открытым текстом и могут быть перехвачены.
- **Действия:**
  - Размещайте фронт и бэкенд за reverse proxy (Nginx, Caddy) с валидным TLS-сертификатом.
  - Используйте Let's Encrypt (бесплатно) или платный сертификат.
  - В Nginx/Caddy включите редирект HTTP → HTTPS (код 301/308).

### 1.2 HSTS (HTTP Strict Transport Security)

- Заставляет браузер всегда ходить по HTTPS и снижает риск перехвата при первом заходе по HTTP.
- **Действия:** добавить заголовок на уровне reverse proxy или в приложении:
  ```http
  Strict-Transport-Security: max-age=31536000; includeSubDomains; preload
  ```
- В бэкенде можно добавить в `SecurityHeadersMiddleware` (см. раздел 5).

### 1.3 Безопасность TLS

- На сервере отключайте устаревшие протоколы (SSLv3, TLS 1.0/1.1) и слабые шифры.
- В Nginx: `ssl_protocols TLSv1.2 TLSv1.3;` и современные `ssl_ciphers`.
- Периодически проверяйте конфиг через [SSL Labs](https://www.ssllabs.com/ssltest/).

---

## 2. Ключи и секреты

### 2.1 JWT_SECRET

- **Сейчас:** в коде используется `JWT_SECRET` из `.env`; при отсутствии — дефолт `dev_secret_change_me`.
- **Рекомендации:**
  - В продакшене **обязательно** задавать свой длинный случайный `JWT_SECRET` (минимум 32 символа, лучше 64+).
  - Никогда не коммитить секрет в репозиторий; хранить только в `.env` или в переменных окружения на сервере.
  - Генерация: `openssl rand -hex 32` или аналог.
- В приложении уже есть предупреждение в логах при дефолтном/пустом секрете — в проде это не должно появляться.

### 2.2 Ротация секретов

- Периодическая смена `JWT_SECRET` и паролей БД/SMTP снижает ущерб при утечке.
- При смене JWT_SECRET все выданные токены станут невалидны (пользователям нужно войти заново) — планируйте окно или делайте поэтапно (два секрета с проверкой по очереди).

### 2.3 Хранение

- `.env`, `mail.env` — в `.gitignore`, не в git.
- На сервере предпочтительно переменные окружения (systemd, Docker, панель хостинга), а не файлы с паролями в репозитории.
- Права на файлы с секретами: только чтение для пользователя, под которым крутится приложение.

---

## 3. Аутентификация и сессии

### 3.1 Токены (JWT)

- Срок жизни токена задаётся `ACCESS_TOKEN_EXPIRE_MINUTES` (сейчас до 30 дней) — для максимальной безопасности можно уменьшить (например 60–120 минут) и ввести **refresh token** для продления без повторного ввода пароля.
- В JWT не хранить чувствительные данные (пароль, полный email и т.д.) — только идентификатор пользователя и срок действия.

### 3.2 Где хранить токен на клиенте

- **Сейчас:** токен в `localStorage`. Удобно для SPA, но при XSS токен может быть украден.
- **Усиление:**
  - Вариант 1: **httpOnly cookie** для хранения токена (или refresh token). Тогда JavaScript не имеет доступа — меньше риска при XSS. Нужна настройка CORS и SameSite, защита от CSRF (см. ниже).
  - Вариант 2: оставить localStorage, но жёстко снизить риски XSS (санитизация, CSP, короткий срок жизни токена).

### 3.3 Уже реализовано

- Учёт устройств/сессий и возможность отзыва (раздел «Настройки»).
- Пароли хранятся в виде хеша (bcrypt), не в открытом виде.
- Подтверждение email по коду — снижает риск захвата аккаунта по почте.

---

## 4. Приватность пользователей

### 4.1 Уже есть

- Скрытие телефона и email от других пользователей по настройкам (`hide_phone`, `hide_email`) в настройках приватности.
- Маскирование email/телефона в API при просмотре чужого профиля.

### 4.2 Рекомендуемые дополнения (по желанию)

- **Кто видит последнюю активность (last_seen):** только друзья / никто / все (настройка в профиле).
- **Кто может писать в личку:** все / только друзья / никто.
- **Видимость списка друзей:** все / только друзья / скрыто.
- **Индексация профиля поисковиками:** опция «не индексировать мой профиль» (реализуется через мета-теги и/или robots.txt для личных страниц).
- **История активности:** возможность очистки или автоудаления старых данных (логины, действия) по истечении срока.

Чем больше таких переключателей «по предпочтениям пользователя», тем выше доверие и соответствие ожиданиям приватности.

---

## 5. Защита от атак

### 5.1 XSS (Cross-Site Scripting)

- **Уже сделано:** валидация и запрет опасных символов в username/email (сервер), заголовок `X-XSS-Protection: 1; mode=block`.
- **Дополнительно:**
  - На фронте не вставлять пользовательский контент через `dangerouslySetInnerHTML` без санитизации (или не использовать вообще).
  - Включить **Content-Security-Policy (CSP)** в заголовках ответа: ограничить источники скриптов, стилей, запросов. Это сильно снижает последствия XSS.
  - Для постов/комментариев/био — экранирование HTML или рендер только «безопасного» подмножества (например, markdown без raw HTML).

### 5.2 CSRF (Cross-Site Request Forgery)

- При использовании **cookie** для авторизации CSRF становится актуальным: сайт злоумышленника может инициировать запрос от имени пользователя.
- **Меры:** проверка заголовка `Origin`/`Referer` на бэкенде; использование **SameSite=Strict** (или Lax) для cookie; при необходимости — CSRF-токен для критичных операций (смена пароля, email, удаление аккаунта).
- При текущей схеме с **Bearer в Authorization** и запросами с того же домена риск CSRF ниже, но при переходе на cookie его нужно учитывать.

### 5.3 Brute-force и перебор паролей

- Ограничение попыток входа по IP или по логину:
  - Блокировка или капча после N неудачных попыток за короткий интервал (например, 5 за 15 минут).
  - Можно реализовать через Redis/ in-memory счётчик и middleware на FastAPI.
- Обязательная **сложность пароля** при регистрации (уже есть минимум 6 символов; можно добавить требование букв + цифр/символов).
- Подтверждение по email уже не даёт войти без доступа к почте — это дополнительный барьер.

### 5.4 Rate limiting (ограничение частоты запросов)

- Защита от DDoS и перебора: лимиты на количество запросов с одного IP (или с одного пользователя) в минуту.
- Особенно важно для: `/api/auth/login`, `/api/auth/register`, `/api/auth/send-verification-code`, `/api/auth/verify-email`, публичных GET.
- Реализация: middleware + Redis или in-memory (например, slowapi для FastAPI или свой счётчик по IP).

### 5.5 SQL-инъекции

- Запросы через параметризованные вызовы (asyncpg, aiosqlite с `?`/`$1`) уже используются — это защищает от классических SQL-инъекций. Важно не склеивать SQL со строками от пользователя.

### 5.6 Дополнительные заголовки безопасности

- Уже выставляются: `X-Content-Type-Options: nosniff`, `X-Frame-Options: DENY`, `X-XSS-Protection: 1; mode=block`.
- Рекомендуется добавить (в том же middleware или в Nginx):
  - **Strict-Transport-Security** (см. п. 1.2).
  - **Content-Security-Policy** — начать с базового набора директив и ужесточать по мере необходимости.
  - **Referrer-Policy: strict-origin-when-cross-origin** — ограничить утечку URL в Referer.
  - **Permissions-Policy** — отключить ненужные API браузера (камера, геолокация и т.д.), если не используются.

### 5.7 CORS

- **Сейчас:** `CORS_ORIGINS` из env, по умолчанию `*` (разрешены все источники).
- В продакшене задать **конкретный список** доменов фронта, например: `https://maksum.example.com,https://www.maksum.example.com`, без `*`, чтобы запросы с левых сайтов не принимались.

---

## 6. Данные и резервное копирование

- **Пароли:** хранить только в виде стойкого хеша (bcrypt — уже используется).
- **Чувствительные поля в БД:** при необходимости можно шифровать поля (например, телефон) с помощью ключа, хранящегося в окружении; расшифровка только при отображении авторизованному пользователю.
- **Бэкапы БД:** регулярные автоматические бэкапы (pg_dump для PostgreSQL, копирование файла для SQLite) с хранением в защищённом месте и проверкой восстановления.
- **Логи:** не логировать пароли, токены и полные тела запросов с секретами; логировать только факты доступа и ошибок (например, «неудачный вход для user_id»).

---

## 7. Деплой и инфраструктура

- Запуск бэкенда от непривилегированного пользователя (не root).
- Минимальные открытые порты: снаружи только 80/443; бэкенд слушает localhost или внутреннюю сеть, снаружи доступ только через reverse proxy.
- Обновление зависимостей (Python, Node, пакеты) и своевременное применение патчей безопасности.
- Мониторинг: логи, алерты на массовые 401/403, резкий рост трафика или ошибок.

---

## 8. Чек-лист внедрения (приоритеты)

| Приоритет | Мера | Сложность |
|-----------|------|------------|
| Высокий | HTTPS + редирект HTTP→HTTPS на проде | Низкая |
| Высокий | Уникальный длинный JWT_SECRET в проде, не коммитить | Низкая |
| Высокий | CORS: указать конкретные домены вместо `*` | Низкая |
| Высокий | Rate limit на логин/регистрацию/отправку кода | Средняя |
| Средний | HSTS и при необходимости CSP | Низкая/средняя |
| Средний | Ограничение неудачных попыток входа (brute-force) | Средняя |
| Средний | Доп. настройки приватности (видимость last_seen, кто может писать) | Средняя |
| Низкий | Refresh token и сокращение срока жизни access token | Высокая |
| Низкий | httpOnly cookie вместо localStorage | Высокая (меняет фронт и CORS) |

Документ можно дополнять по мере внедрения мер и появления новых угроз. Регулярный пересмотр раз в полгода–год полезен для поддержания уровня безопасности Maksum.
